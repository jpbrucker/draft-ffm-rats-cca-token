---
v: 3

title: "Arm's Confidential Compute Architecture Reference Attestation Token"
abbrev: "CCA Reference Attestation Token"
docname: draft-ffm-rats-cca-token-latest
category: info
submissionType: independent

ipr: trust200902
area: ""
workgroup: ""
keyword: Internet-Draft

stand_alone: yes

pi:
  rfcedstyle: yes
  toc: yes
  tocindent: yes
  sortrefs: yes
  symrefs: yes
  strict: yes
  comments: yes
  text-list-symbols: -o*+

author:
 -  name: Simon Frost
    organization: Arm Limited
    email: Simon.Frost@arm.com
 -  name: Thomas Fossati
    organization: Linaro
    email: thomas.fossati@linaro.org
 -  name: Giri Mandyam
    organization: Mediatek Inc
    email: giridhar.mandyam@gmail.com
contributor:
 -  name: Yogesh Deshpande
    organization: Arm Limited
    email: Yogesh.Deshpande@arm.com
 -  name: Sergei Trofimov
    organization: Arm Limited
    email: Sergei.Trofimov@arm.com

normative:
  CCA-ARCH:
    author:
      org: Arm
    title: Learn the architecture - Introducing Arm Confidential Compute Architecture
    target: https://developer.arm.com/documentation/den0125/0300
    date: 09. May. 2023
  RMM:
    author:
      org: Arm
    title: Realm Management Monitor specification 1.0
    target: https://developer.arm.com/documentation/den0137/1-0bet2
    date: 16. Dec. 2022
  RME:
    author:
      org: Arm
    title: Learn the architecture - Realm Management Extension
    target: https://developer.arm.com/documentation/den0126/0100
    date: 23. June. 2021
  STD94:
    -: cbor
    =: RFC8949
  STD96:
    -: cose
    =: RFC9052
  COSE-ALGS: RFC9053
  IANA-CWT:
    author:
      org: IANA
    title: CBOR Web Token (CWT) Claims
    target: https://www.iana.org/assignments/cwt/cwt.xhtml#claims-registry
    date: 2022
  EAT: I-D.ietf-rats-eat
  EAT-MEDIATYPES: I-D.ietf-rats-eat-media-type
  CMW: I-D.draft-ietf-rats-msg-wrap


informative:
  I-D.kdyxy-rats-tdx-eat-profile:
  I-D.mandyam-rats-qwestoken:
  COSE-X509: RFC9360
  RFC9334:
  IANA-CoAP-Content-Formats:
    author:
      org: IANA
    title: CoAP Content-Formats
    target: https://www.iana.org/assignments/core-parameters
    date: 2022
  TF-RMM:
    author:
      org: Trusted Firmware Project
    title: Trusted Firmware-RMM
    target: https://www.trustedfirmware.org/projects/tf-rmm
    date: 2022
  Veraison:
    author:
      org: The Veraison Project
    title: Veraison ccatoken package
    target: https://github.com/veraison/ccatoken
    date: 2022
  RATS-CoRIM: I-D.ietf-rats-corim
  RATS-AR4SI: I-D.ietf-rats-ar4si
  CCA-ENDORSEMENTS: I-D.draft-ydb-rats-cca-endorsements

entity:
  SELF: "RFCthis"

--- abstract

The Arm Confidential Compute Architecture (CCA) is series of hardware and software
innovations that enhance Armâ€™s support for Confidential Computing for large,
compute-intensive workloads. Devices that implement CCA can produce attestation
tokens as described in this memo, which are the basis for trustworthiness assessment of
the Confidential Compute environment.  This document specifies the CCA attestation
token structure and semantics.

The CCA attestation token is a profile of the Entity Attestation Token (EAT).
This specification describes what claims are used in an attestation token
generated by CCA compliant systems, how these claims get serialized to the
wire, and how they are cryptographically protected.

This informational document is published as an independent submission to improve
interoperability with Arm's architecture. It is not a standard nor
a product of the IETF.

--- middle

# Introduction

The Arm Confidential Compute Architecture (CCA) {{CCA-ARCH}} is a set of hardware {{RME}}
and firmware {{RMM}} specifications, backed by a reference implementation {{TF-RMM}} .

CCA provides confidential compute environments, called Realms, that can be dynamically
allocated by the Normal world host. The initial state of a Realm, and of the platform
on which it executes, can be attested. Attestation allows the Realm owner to establish
trust in the Realm, before provisioning any secrets to it. The Realm does not have to
inherit the trust from the Non-secure hypervisor which controls it.

As outlined in the RATS Architecture {{RFC9334}}, an Attester produces a signed collection
of Claims that constitutes Evidence about its target environment. This document focuses
on the output provided by requests from the Realm to the Realm Management Monitor (RMM) management component for an
attestation token that covers the state of that Realm and the CCA Platform.
This output corresponds to Evidence in {{RFC9334}} and, as a design decision, the CCA attestation
token is a profile of the Entity Attestation Token (EAT) {{EAT}}. Note that there are other profiles
of EAT available, such as {{I-D.kdyxy-rats-tdx-eat-profile}} and {{I-D.mandyam-rats-qwestoken}},
for use with different use cases and by different attestation technologies.

Since the CCA tokens are consumed by services outside the device, there is an actual
need to ensure interoperability. Interoperability needs are addressed here by
describing the exact syntax and semantics of the attestation claims, and
defining the way these claims are encoded and cryptographically protected.

Further details on concepts expressed below can be found in the Realm Management Monitor
specification 1.0 {{RMM}}.

As mentioned in the abstract, this memo documents a vendor extension
to the RATS architecture, and is not a standard.

# Conventions and Definitions

{::boilerplate bcp14}

The terms Attester, Relying Party, Verifier, Attestation Result, Target Environment, Attesting Environment and Evidence
are defined in {{RFC9334}}. We use the term "receiver" to refer to Relying Parties
and Verifiers.

We use the terms Evidence, "CCA attestation token", and "CCA token" interchangeably.
The terms "sender" and Attester are used interchangeably. Likewise, we use the terms
Verifier and "verification service" interchangeably.

{: vspace="0"}
RoT:
: Root of Trust, the minimal set of software, hardware and data that has to be
implicitly trusted in the platform - there is no software or hardware at a
deeper level that can verify that the Root of Trust is authentic and
unmodified.  An example of a RoT suitable
 for CCA would be an isolated
Trusted subsystem responsible for initial measurements, lifecycle state
management, identity and attestation services.  The services that the RoT
provides for securitization of the CCA environment are descibed as Hardware-Enforced Security (HES) -
see Section B4.1.5 of {{RME}}.

Realm-World:
: Realm World, provides a security state and physical address range that provides
an execution environment for VMs that is isolated from the Normal and Secure worlds.
The controlling firmware running in the Realm world can access memory in the Normal
world to allow shared buffers. (This is similar to Trusted Execution Environment (TEE),
"secure world", or "secure enclave".)

Realm:
: the Realm execution environment, is an Arm CCA environment that can be dynamically
allocated by the Normal world Host.

NW-Host:
: Normal world host, refers to the security domain outside of the restricted Root,
Secure and Realm worlds. This typically contains the host hypervisor and supervisory
services. The NW-Host can allocate and manage resource allocation and can manage the
scheduling for other worlds.

In this document, the structure of data is specified in Concise Data Definition Language (CDDL) {{!RFC8610}}.

# CCA Attester Model

There are two kinds of CCA Attester: direct and delegated.
Their architectural arrangements are described in {{direct}} and {{delegated}}, respectively.

## Direct {#direct}

TODO: [Issue #16](https://github.com/SimonFrost-Arm/draft-ffm-rats-cca-token/issues/16)

## Delegated {#delegated}

The structure of the CCA delegated Attester is illustrated in {{fig-cca-delegated-attester}}.
The CCA delegated Attester is a "layered attester" ({{Section 3.2 of RFC9334}}) with exactly two layers: platform and realm.

The Realm Management Monitor (RMM) is the top layer Attesting Environment.
It attests to the initial memory content of each Realm that is executed on a CCA platform, and any dynamic measurements provided by Realm guest code.
It uses its own private key called RAK (Realm Attestation Key) to sign the claims regarding the requesting Realm.

The HES (Hardware Enforced Security) is the bottom layer Attesting Environment, which acts as the CCA platform hardware RoT.
It attests to the executables and configuration contents of the "Monitor Security Domain", which includes the RMM, as well as a few relevant CCA parameters (e.g., the CCA platform implementation identifier), and the security lifecycle state of the platform.
Additionally, it generates the RAK keypair, transfers it over a trusted channel to the RMM, and stores the hash of the RAK public key in a claim that is signed using the CCA Platform Attestation Key (CPAK) as part of the platform Evidence.

The CCA Evidence produced in delegated mode comprises two separately signed EATs, one for the platform, another for the realm, wrapped in a CMW {{CMW}} collection.
The intra-collection binding is detailed in {{sec-token-binding}}.

~~~ aasvg
{::include art/cca-delegated.ascii-art}
~~~
{: #fig-cca-delegated-attester title="CCA Attester" }

## Boot Phase

The HES Attesting Environment is responsible for collecting the information to be
represented in CCA platform claims and to assemble them into Evidence.

The Main Bootloader, executing at boot-time, measures the trusted computing base (TCB) of the Realm World - i.e., loaded firmware components and the associated configuration payloads - and sends them to the HES RoT to be stored isolated.  See {{fig-cca-attester-boot}}.

~~~ aasvg
{::include art/cca-boot.ascii-art}
~~~
{: #fig-cca-attester-boot title="CCA Attester Boot Phase" align="center" }

## Run-time Phase

The Realm Management Monitor (RMM), executing at run-time, maintains measurements for
the state of a Realm. It can respond to requests issued from a Realm for an attestation
token relevant for that Realm by obtaining a CCA Platform attestation token from the
HES RoT and combining that with an attestation token containing Evidence reflecting
Realm state.

{: #para-pak-intro}
The HES RoT, executing at run-time, maintains measurements for the state of the CCA
platform TCB, including the lifecycle state of the CCA platform. It can answer requests
coming from the RMM to collect and format claims corresponding to that state and use a
CCA Platform Attestation Key (CPAK) to sign them (see {{fig-cca-attester-runtime}}).
How the CPAK is derived is implementation-specific.

~~~ aasvg
{::include art/cca-runtime.ascii-art}
~~~
{: #fig-cca-attester-runtime
   title="CCA Attester Run-time Phase"
   align="center" }

A reference implementation of the CCA Attester is provided by {{TF-RMM}}.

# CCA Claims
{: #sec-cca-claims }

This section describes the claims to be used in a CCA reference attestation token.

There are two logical sections within the CCA attestation token, relating to the two
Target Environment elements:

* The CCA Platform token

* The Realm state token

The two sections use inter-related claims to bind together into a single logical unit.
See {{sec-security-consideration}} for more details.

The above tokens are presented to the requester within a top level Conceptual Message WWrapper (CMW) collection {{CMW}}.



CDDL {{!RFC8610}} along with text descriptions is used to define each claim
independent of encoding.  The following CDDL type(s) are reused by different
claims:

~~~
{::include cddl/platform/arm-platform-hash-types.cddl}
~~~

Two conventions are used to encode the Right-Hand-Side (RHS) of a claim: the postfix `-label` is used for EAT-defined claims, and the postfix `-key` for PSA-originated claims.

## CCA Attestation Token top level wrapper
{: #sec-cca-token-collection}


The above tokens are presented to the requester within a top level CMW collection {{CMW}}.
The collection map has two entries, one for a bstr encoding of the CCA Platform token and
the other for a bstr encoding of the Realm state token/

~~~
{::include cddl/top/cca-top-claims.cddl}
~~~


## CCA Platform token Claims

## Caller Claims

### CCA Platform Nonce
{: #sec-platform-nonce-claim}

The Nonce claim is used to carry a challenge provided by the caller to demonstrate freshness of the generated token.

The EAT {{EAT}} `nonce` (claim key 10) is used.  Since the EAT nonce claim offers flexiblity for different
attestation technologies, this specifications applies the following constraints
 to the `nonce-type`:

* The length MUST be either 32, 48, or 64 bytes.
* Only a single nonce value is conveyed. The array notation MUST NOT be used for encoding the nonce value.

Where the CCA Platform implementation uses the Delegated Token signing model {{sec-token-binding}}, the
value of the Nonce claim will be a hash of the Realm Public Key claim of the CCA Realm State token
{{sec-realm-public-key-claim}}.

This claim MUST be present in a CCA Platform attestation token.

~~~
{::include cddl/platform/arm-platform-challenge.cddl}
~~~

## Target Identification Claims

### CCA Platform Instance ID
{: #sec-instance-id-claim}

The Instance ID claim represents the unique identifier of the Platform
Attestation Key (PAK).
The EAT `ueid` (claim key 256) of type RAND is used.  The following constraints
apply to the `ueid-type`:

* The length MUST be 33 bytes.
* The first byte MUST be 0x01 (RAND) followed by the 32-byte unique identifier of the PAK.

~~~ cbor-diag
{::include cddl/platform/eat-ueid-rand.cddl}
~~~

This claim MUST be present in a CCA Platform attestation token.

~~~
{::include cddl/platform/arm-platform-instance-id.cddl}
~~~

### CCA Platform Implementation ID
{: #sec-implementation-id}

The Implementation ID claim uniquely identifies the implementation of the
CCA Platform. A verification service uses this claim to locate the
details of the CCA Platform implementation from an Endorser or manufacturer.
Such details are used by a verification service to determine the security properties
or certification status of the CCA Platform implementation.

The value and format of the ID is decided by
the manufacturer or a particular certification scheme. For example, the ID
could take the form of a product serial number,
database ID, or other appropriate identifier.

This claim MUST be present in a CCA Platform attestation token.

Note that this identifies the CCA Platform implementation, not a particular instance.
To uniquely identify an instance, see the Instance ID claim {{sec-instance-id-claim}}.

~~~
{::include cddl/platform/arm-platform-implementation-id.cddl}
~~~

## Target State Claims

### CCA Platform Profile Definition
{: #sec-plat-profile-definition-claim}

The CCA platform profile claim identifies the EAT profile to which the CCA platform token
conforms. This allows a receiver to assign the intended semantics to the rest of the claims
found in the token.

The EAT `eat_profile` (claim key 265) is used.

The format of the CCA platform profile claim is defined as a text string of value
"tag:arm.com,2023:cca_platform#1.0.0".

This claim MUST be present in a CCA Platform attestation token.

See {{sec-backwards-compat}}, for considerations about backwards compatibility
with previous versions of the CCA Platform attestation token format.

~~~
{::include cddl/platform/arm-platform-profile.cddl}
~~~


### Security Lifecycle
{: #sec-security-lifecycle }

The Security Lifecycle claim represents the current lifecycle state of the CCA
Platform.

The state is represented by an integer that is divided as follows:

* major\[15:8\] - CCA Platform security lifecycle state, and
* minor\[7:0\] - IMPLEMENTATION DEFINED state.

The CCA Platform lifecycle states are illustrated in {{fig-lifecycle-states}}.
A non debugged CCA platform will be in psa-lifecycle-secured state.
Realm Management Security Domain debug is always recoverable, and would
therefore be represented by psa-lifecycle-non-psa-rot-debug state. Root
world debug is recoverable on a HES system and would be represented by
psa-lifecycle-recoverable-psa-rot state. On a non-HES system Root world
debug is usually non-recoverable, and would be represented by
psa-lifecycle-lifecycle-decommissioned state


This claim MUST be present in a CCA Platform attestation token.

~~~ aasvg
{::include art/cca-lifecycle.ascii-art}
~~~
{: #fig-lifecycle-states title="CCA Platform Lifecycle States" }

The CDDL representation is shown below.
{{tab-states-map}} provides the mappings between {{fig-lifecycle-states}} and the data model.

~~~
{::include cddl/platform/arm-platform-security-lifecycle.cddl}
~~~

`psa-lifecycle-unknown-type` is not shown in {{fig-lifecycle-states}}; it represents an invalid state that must not occur in a system.

| CDDL | Lifecycle States |
|------|------------------|
| `psa-lifecycle-unknown-type`                   | |
| `psa-lifecycle-assembly-and-test-type`         |  Assembly and Test |
| `psa-lifecycle-psa-rot-provisioning-type`      |  CCA Platform Provisioning |
| `psa-lifecycle-secured-type`                   |  Secured |
| `psa-lifecycle-non-psa-rot-debug-type`         |  Non-Recoverable CCA Platform Debug |
| `psa-lifecycle-recoverable-psa-rot-debug-type` |  Recoverable CCA Platform Debug |
| `psa-lifecycle-decommissioned-type`            |  Decommissioned |
{: #tab-states-map title="Lifecycle States Mappings"}

### Platform Config
{: #sec-platform-config }

The CCA platform config claim describes the set of chosen implementation options
of the CCA platform. As an example, these may include a description of the level
of physical memory protection which is provided.

The CCA platform config claim is expected to contain the System Properties field
which is present in the Root Non-volatile Storage (RNVS) public parameters.

This claim MUST be present in a CCA Platform attestation token.

~~~
{::include cddl/platform/arm-platform-config.cddl}
~~~

## Software Inventory Claims

### Software Components
{: #sec-sw-components }

The Software Components claim is a list of software components which can affect
the behavior of the CCA platform.

This claim MUST be present in a CCA Platform attestation token.

Each entry in the Software Components list describes one software component
using the attributes described in the following subsections.  Unless explicitly
stated, the presence of an attribute is OPTIONAL.

Note that, as described in {{RFC9334}}, a relying party will typically see the
result of the appraisal process from the Verifier in form of an Attestation
Result, rather than the CCA Platform token from the attesting endpoint.
Therefore, a relying party is not expected to understand the Software
Components claim.  Instead, it is for the Verifier to check this claim against
the available Reference Values and provide an answer in form of an "high level"
Attestation Result, which may or may not include the original Software
Components claim.

~~~
{::include cddl/platform/arm-platform-software-components.cddl}
~~~

#### Component Type

The Component Type attribute (key=1) is a short string representing the role of
this software component. This attribute is intended for use as a hint to help
the verifier understand how to evaluate the CCA platform software component
measurement value.

This attribute is optional in a CCA Platform software component.

#### Measurement Value

The Measurement Value attribute (key=2) represents a hash of the invariant
software component in memory at the time it was initialized.
The value MUST be a cryptographic hash of 256 bits or stronger.

This attribute MUST be present in a PSA software component.

#### Version

The Version attribute (key=4) is the issued software version in the form of a
text string. The meaning of this string is defined by the software component
vendor.

This attribute is optional in a CCA Platform software component.

#### Signer ID

The Signer ID attribute (key=5) uniquely identifies the signer of the software component.
The identification is typically accomplished by hashing the signer's public key.
The value of this attribute will correspond to the
entry in the original manifest for the component. This can be used by a
Verifier to ensure the components were signed by an expected trusted source.

This attribute MUST be present in a CCA Platform software component.

#### Measurement Description

The Measurement Description attribute (key=6) contains a string identifying the
hash algorithm used to compute the corresponding Measurement Value.  The string
SHOULD be encoded according to "Hash Name String" in the "Named Information Hash Algorithm Registry" {{!IANA.named-information}}.

#### Measurement Description

The Measurement Description attribute (key=6) contains a string identifying the
hash algorithm used to compute the corresponding Measurement Value.  The string
SHOULD be encoded according to "Hash Name String" in the "Named Information Hash Algorithm Registry" {{!IANA.named-information}}.

## Verification Claims

The following claims are part of the CCA Platform token (and therefore still Evidence)
but aim to help receivers, including relying parties, with the
processing of the received attestation Evidence.

### Verification Service Indicator
{: #sec-verification-service-indicator}

The Verification Service Indicator claim is a hint used by a relying party to
locate a verification service for the token. The value is a text string that
can be used to locate the service (typically, a URL specifying the address of
the verification service API). A Relying Party may choose to ignore this claim
in favor of other information.

~~~
{::include cddl/platform/arm-platform-verification-service-indicator.cddl}
~~~

It is assumed that the relying party is pre-configured with a list of trusted
verification services and that the contents of this hint can be used to look
up the correct one. Under no circumstances must the relying party be tricked
into contacting an unknown and untrusted verification service since the
returned Attestation Result cannot be relied on.

Note: This hint requires the relying party to parse the content of the
CCA Platform token. Since the relying party may not be in possession of a trust
anchor to verify the digital signature, it uses the hint in the same way
as it would treat any other information provided by an external party,
which includes attacker-provided data.

The CCA platform verification service indicator claim is OPTIONAL in a CCA platform token.

### CCA Platform Hash Algorithm ID
{: #sec-arm-platform-hash-algm-id}

The CCA platform hash algorithm ID claim is a text string that identifies
the algorithm used to calculate the extended measurements in the CCA platform token.

The string SHOULD be encoded according to "Hash Name String" in the "Named
Information Hash Algorithm Registry" {{!IANA.named-information}}.

The CCA platform hash algorithm ID claim MUST be present in a CCA platform token.

~~~
{::include cddl/platform/arm-platform-hash-algm-id.cddl}
~~~


## CCA Realm state token Claims

The CCA Realm state token contains claims that represent the Target Environment
that is the Realm that requested the attestation report.

### Realm Nonce
{: #sec-realm-nonce-claim}

The Nonce claim is used to carry a challenge provided by the caller to demonstrate freshness of the generated token.

The EAT {{EAT}} `nonce` (claim key 10) is used.  Since the EAT nonce claim offers flexiblity for different
attestation technologies, this specification applies the following constraints
 to the `nonce-type`:

* The length MUST be 64 bytes.
* Only a single nonce value is conveyed. The array notation MUST NOT be used for encoding the nonce value.


This claim MUST be present in a CCA Realm state attestation token.

~~~
{::include cddl/realm/cca-realm-challenge.cddl}
~~~

### CCA Platform Profile Definition
{: #sec-realm-profile-definition-claim}

The Realm profile claim identifies the EAT profile to which the Realm token
conforms. This allows a receiver to assign the intended semantics to the rest of the claims
found in the token.

The EAT `eat_profile` (claim key 265) is used.

The format of the CCA platform profile claim is defined as a text string of value
"tag:arm.com,2023:realm#1.0.0".

This claim is OPTIONAL in a CCA Realm attestation token.
If the Realm profile is not included in a CCA Realm token then the profile value
used in the CCA Platform token should refer to a profile that describes both
Platform and Realm claims.


~~~
{::include cddl/realm/cca-realm-profile.cddl}
~~~

### Realm Personalisation Value
{: #sec-realm-personalisation-value-claim}

The Realm Personalization Value (RPV) claim contains the RPV which was provided
at Realm creation.

This claim MUST be present in a CCA Realm state attestation token.

~~~
{::include cddl/realm/cca-realm-personalization-value.cddl}
~~~

### Realm Initial Measurement
{: #sec-realm-initial-measurement-claim}

The Realm Initial Measurement claim contains the compound extension of
measurements taken of Realm memory and state before the Realm is activated.

This claim MUST be present in a CCA Realm state attestation token.

~~~
{::include cddl/realm/cca-realm-initial-measurement.cddl}
~~~

### Realm Extensible Measurements
{: #sec-realm-extensible-measurements-claim}

The Realm Extensible Measurements claim contains measurements provided by Realm
guest software and extended to the set of Realm Extensible Measurements
maintained by the RMM.

This claim MUST be present in a CCA Realm state attestation token.

~~~
{::include cddl/realm/cca-realm-extensible-measurements.cddl}
~~~

### Realm Hash Algorithm Measurements
{: #sec-realm-hash-algm-id-claim}

The Realm hash algorithm ID claim identifies the algorithm used to calculate
all hash values which are present in the Realm token.

The string value of the claim SHOULD be encoded according to "Hash Name String"
in the "Named Information Hash Algorithm Registry" {{!IANA.named-information}}.

This claim MUST be present in a CCA Realm state attestation token.

~~~
{::include cddl/realm/cca-realm-hash-algo-id.cddl}
~~~

### Realm Public Key
{: #sec-realm-public-key-claim}

The Realm public key claim identifies the attestation key which is used to sign the Realm token

The value of the Realm public key claim is a byte string representation of a COSE_Key.

This claim MUST be present in a CCA Realm state attestation token.

~~~
{::include cddl/realm/cca-realm-public-key.cddl}
~~~


### Realm Public Key Hash Algorithm ID
{: #sec-realm-public-key-hash-algo-id-claim}

The Realm public key hash algorithm identifier claim identifies the algorithm used to
hash the value of the Realm Public Key claim {{sec-realm-public-key-claim}}
such that it can be presented as a Challenge for the bound CCA Platform token
{{sec-token-binding}}.

This claim MUST be present in a CCA Realm state attestation token.

~~~
{::include cddl/realm/cca-realm-public-key-hash-algo-id.cddl}
~~~


## Backwards Compatibility Considerations
{: #sec-backwards-compat}

This profile conforms to the claims in the Beta2 release of the 1.0 release of the
Realm Management Monitor specification. {{RMM}}. There has not been a prior
release of this specification to the 1.0 release. Hence this section is a
place holder for claim changes introduced in future releases.

## Token Binding
{: #sec-token-binding}

The reference implementation uses a 'Delegated Model' for token signing.
In this model, the completion of signing operations for the CCA token is
delegated from the CCA Platform RoT to the RMM. When the RMM initialises,
it obtains a 'Realm Attestation Token' (RAK) signing key pair from the CCA
Platform RoT. The public part of that key pair is hashed and used as a
challenge to obtain a CCA Platform token (signed by the CCA Platform RoT).
When guest code in a Realm requests a CCA Attestation token, the RMM
prepares a Realm state token, signed by the RAK private key, then wraps
both tokens in a CMW Collection. The two tokens are bound together by
the Nonce claim in the CCA Platform token having the same value as a
hash of the Realm Public key claim in the Realm state token (using the
hash algorithm identified by the Realm Public Key Hash Algorithm ID claim).

A verifier MUST check this binding is valid when verifying a CCA
Attestation token.

An implementation may choose instead a 'Direct Model'. In this model,
when guest code in a Realm requests a CCA Attestation token, the RMM
prepares a Realm state claim set, but does not wrap it in a CMW.
Instead, the claim set is hashed and this value is used as a Challenge
to obtain a CCA Platform token, signed by the CCA Platform RoT. The
CCA Platform and Realm state claim set are presented within a CMW Collection
as in the Delegated model. The two parts of the collection are bound
together by the Nonce claim in the CCA Platform token having the same value
as the hash of the Realm state claim set. If the Direct Model is used,
the CCA Platform profile claim {{sec-plat-profile-definition-claim}} MUST
have a different value from the reference profile. The map value within
the CCA Attestation token CMW Collection for the Realm state claim set
MUST also have a different value to that used for a Realm state CMW
token. In such a profile, the Realm Public Key {{sec-realm-public-key-claim}}
and Realm Public Key Hash Algorithm ID {{sec-realm-public-key-hash-algo-id-claim}} claims
will not be used.


## Reference Profile
{: #sec-reference-profile}


### Token Encoding and Signing
{: #sec-token-encoding-and-signing}

The CCA attestation token is encoded in CBOR {{STD94}} format.
The CBOR representation of a CCA attestation token MUST be "valid" according to the definition in {{Section 1.2 of STD94}}.
Besides, only definite-length string, arrays, and maps are allowed.

Given that a PSA Attester is typically found in a constrained device, it MAY
NOT emit CBOR preferred serializations ({{Section 4.1 of STD94}}).
Therefore, the Verifier MUST be a variation-tolerant CBOR decoder.
TODO: [Issue #31](https://github.com/SimonFrost-Arm/draft-ffm-rats-cca-token/issues/31) need different narrative from IoT reasons

Cryptographic protection is obtained by wrapping the CCA Platform and Realm state claims-set in a COSE
Web Token (CWT) {{!RFC8392}}.  The signature structure MUST be a tagged (18) COSE_Sign1 {{STD96}}.

Acknowledging the variety of markets, regulations and use cases in which the
CCA attestation token can be used, the baseline profile does not impose any
strong requirement on the cryptographic algorithms that need to be supported by
Attesters and Verifiers.  The flexibility provided by the COSE format should be
sufficient to deal with the level of cryptographic agility needed to adapt to
specific use cases.  It is RECOMMENDED that commonly adopted algorithms are
used, such as those discussed in {{COSE-ALGS}}.  It is expected that receivers
will accept a wider range of algorithms, while Attesters would produce CCA tokens
using only one such algorithm.

The CCA Platform token is always directly signed by the CCA Platform RoT.  Therefore, the CCA
claims-set is never carried in a Detached EAT bundle
({{Section 5 of EAT}}).

### Freshness Model

The CCA token supports the freshness models for attestation Evidence based on
nonces and epoch handles ({{Section 10.2 and Section 10.3 of RFC9334}}) using
the `nonce` claim to convey the nonce or epoch handle supplied by the Verifier.
No further assumption on the specific remote attestation protocol is made.

Note that use of epoch handles is constrained by the type restrictions imposed by the `eat_nonce` syntax.
For use in CCA tokens, it must be possible to encode the epoch handle as an opaque binary string between 8 and 64 octets.

### Synopsis

{{tbl-baseline-profile}} presents a concise view of the requirements described in the preceding sections.

| Issue | Profile Definition |
| CBOR/JSON | CBOR MUST be used  |
| CBOR Encoding | Definite length maps and arrays MUST be used |
| CBOR Encoding | Definite length strings MUST be used |
| CBOR Serialization | Variant serialization MAY be used |
| COSE Protection | COSE_Sign1 MUST be used |
| Algorithms | {{COSE-ALGS}} SHOULD be used |
| Detached EAT Bundle Usage | Detached EAT bundles MUST NOT be sent |
| Verification Key Identification | Any identification method listed in {{Appendix F.1 of EAT}} |
| Endorsements | See {{sec-cca-endorsements}} |
| Freshness | nonce or epoch ID based |
| Claims | Those defined in {{sec-cca-claims}}. As per general EAT rules, the receiver MUST NOT error out on claims it does not understand. |
{: #tbl-baseline-profile title="Baseline Profile"}



# Collated CDDL

~~~
TODO...include cddl/cca-attestation.cddl
~~~

# Signing key implementation alternatives
{: #sec-signing-keys}

In the CCA Platform reference design, PAKs ({{para-pak-intro}}) are raw public keys.

Some implementations may choose to use a PAK that is a certified public key. If
this option is taken, the value of the CCA Platform Profile Definition claim
{{sec-plat-profile-definition-claim}} MUST be altered from the reference implementation
value.

TODO: [Issue #32](https://github.com/SimonFrost-Arm/draft-ffm-rats-cca-token/issues/32) Cut the following block?

Certified public keys require the manufacturer to run the certification
authority (CA) that issues X.509 certs for the PAKs.  (Note that operating a CA
is a complex and expensive task that may be unaffordable to certain
manufacturers.)

Using certified public keys offers better scalability properties when compared to using raw public keys, namely:

* storage requirements for the Verifier are minimised - the same
  manufacturer's trust anchor is used for any number of devices,
* the provisioning model is simpler and more robust since there is no need to
  notify the Verifier about each newly manufactured device,

Furthermore, existing and well-understood revocation mechanisms can be readily used.

TODO: [Issue #35](https://github.com/SimonFrost-Arm/draft-ffm-rats-cca-token/issues/35) improve cert description

The PAK's X.509 cert can be inlined in the CCA Platform token using the `x5chain` COSE
header parameter {{COSE-X509}} at the cost of an increase in the CCA Platform token
size.
Note that the exact split between pre-provisioned and inlined certs may vary
depending on the specific deployment.  In that respect, `x5chain` is quite
flexible: it can contain the end-entity (EE) cert only, the EE and a partial
chain, or the EE and the full chain up to the trust anchor (see {{Section 2 of
COSE-X509}} for the details).


TODO: [Issue #33](https://github.com/SimonFrost-Arm/draft-ffm-rats-cca-token/issues/33) lose following as IoT centric??

Constraints around network bandwidth and computing resources available to endpoints,
such as network buffers, may dictate a reasonable split point.


# CCA Attestation Token Verification

To verify the token for the reference profile, the initial need is to check correct
encoding for the token. Primary trust is established by checking the signing of
the CCA Platform token CWT.
The key used for verification is supplied to the Verifier by an
authorized Endorser along with the corresponding Attester's Instance ID.
For the verifier, the CCA Platform Instance ID {{sec-instance-id-claim}} claim is
used to assist locating the key used to verify the signature covering the CCA Platform
CWT token. The verifier can also be supplied with the information that the
key instance has been revoked and is no longer valid.

Additional validation checks on the token are:

* Checking that the binding between the CCA Platform token and the Realm state
token is valid {{sec-token-binding}}}. This has the side effect of establishing
the trustworthiness of the RAK public key.
* Validating that the Realm state token is correctly signed by the RAK.
* Checking that the value of the lll claim is psa-lifecycle-secured state. Note
that some other values of this claim (psa-lifecycle-non-psa-rot-debug and
psa-lifecycle-recoverable-psa-rot states) may indicate that the attester
is only temporarily unsuitable and the verifier may choose the to indicate
this as a contraindication rather than a full verification failure. See discussion
of the CCA platform lifecycle in {{RMM}}.

The Verifier will typically operate a policy where values of some
of the claims in this profile can be compared to reference values, registered
with the Verifier for a given deployment, in order to confirm that the device
is endorsed by the manufacturer supply chain.  The policy may require that the
relevant claims must have a match to a registered reference value.  All claims
may be worthy of additional appraisal.  It is likely that most deployments
would include a policy with appraisal for the following claims:

* Implementation ID - the value of the Implementation ID can be used to
  identify the verification requirements of the deployment.
* Software Component, Measurement Value - this value can uniquely identify a
  firmware release from the supply chain. In some cases, a Verifier may
  maintain a record for a series of firmware releases, being patches to an
  original baseline release. A verification policy may then allow this value to
  match any point on that release sequence or expect some minimum level of
  maturity related to the sequence.
* Software Component, Signer ID - where present in a deployment, this could
  allow a Verifier to operate a more general policy than that for Measurement
  Value as above, by allowing a token to contain any firmware entries signed by
  a known Signer ID, without checking for a uniquely registered version.

## AR4SI Trustworthiness Claims Mappings

{{RATS-AR4SI}} defines an information model that Verifiers can employ to
produce Attestation Results.
AR4SI provides a set of standardized appraisal categories and tiers that
greatly simplifies the task of writing Relying Party policies in multi-attester
environments.

The contents of {{tab-ar4si-map}} are intended as guidance for implementing a
PSA Verifier that computes its results using AR4SI.
The table describes which PSA Evidence claims (if any) are related to which
AR4SI trustworthiness claim, and therefore what the Verifier must consider when
deciding if and how to appraise a certain feature associated with the PSA
Attester.

Trustworthiness Vector claims | Related PSA claims
---|---
`configuration` | Software Components ({{sec-sw-components}})
`executables` | ditto
`file-system` | N/A
`hardware` | Implementation ID ({{sec-implementation-id}}) and CCA Platform config (TODO)
`instance-identity` | Instance ID ({{sec-instance-id-claim}}).  The Security Lifecycle ({{sec-security-lifecycle}}) can also impact the derived identity.
`runtime-opaque` | Indirectly derived from `executables`, `hardware`, and `instance-identity`.  The Security Lifecycle ({{sec-security-lifecycle}}) can also be relevant: for example, any debug state will expose otherwise protected memory.
`sourced-data` | N/A
`storage-opaque` | Indirectly derived from `executables`, `hardware`, and `instance-identity`.
{: #tab-ar4si-map title="AR4SI Claims mappings"}

This document does not prescribe what value must be chosen based on each
possible situation: when assigning specific Trustworthiness Claim values, an
implementation is expected to follow the algorithm described in {{Section 2.3.3
of RATS-AR4SI}}.

## Endorsements, Reference Values and Verification Key Material
{: #sec-cca-endorsements}

The {{CCA-ENDORSEMENTS}} defines a protocol based on the {{RATS-CoRIM}} data model
that can be used to convey CCA Endorsements, Reference Values and Verification
Key Material to the Verifier.

# Implementation Status

[^rfc-ed-note] please remove this section before publication.

Implementations of this specification are provided by the Trusted
Firmware-RMM project {{TF-RMM}} and the Veraison project {{Veraison}}.
These implementations are released as open-source software.


# Security and Privacy Considerations
{: #sec-security-consideration}
This specification re-uses the EAT specification and therefore the CWT specification.
Hence, the security and privacy considerations of those specifications apply here as well.

Attestation tokens contain information that may be unique to a device and
therefore they may allow singling out an individual device for tracking
purposes.  Deployments that have privacy requirements must take appropriate
measures to ensure that the token is only used to provision anonymous/pseudonym
keys.

# IANA Considerations

## CBOR Web Token Claims Registration

IANA is requested to make permanent the following claims that have been
assigned via early allocation in the "CBOR Web Token (CWT) Claims" registry
{{IANA-CWT}}.

### Security Lifecycle Claim

* Claim Name: arm-platform-security-lifecycle
* Claim Description: Arm Platform Security Lifecycle
* JWT Claim Name: N/A
* Claim Key: 2395
* Claim Value Type(s): unsigned integer
* Change Controller: Hannes Tschofenig      TODO: [Issue #34](https://github.com/SimonFrost-Arm/draft-ffm-rats-cca-token/issues/34) find document centric change controller
* Specification Document(s): {{sec-security-lifecycle}} of {{&SELF}}

### Implementation ID Claim

* Claim Name: arm-platform-implementation-id
* Claim Description: Arm Platform Implementation ID
* JWT Claim Name: N/A
* Claim Key: 2396
* Claim Value Type(s): byte string
* Change Controller: Hannes Tschofenig
* Specification Document(s): {{sec-implementation-id}} of {{&SELF}}

### Software Components Claim

* Claim Name: arm-platform-software-components
* Claim Description: Arm Platform Software Components
* JWT Claim Name: N/A
* Claim Key: 2399
* Claim Value Type(s): array
* Change Controller: Hannes Tschofenig
* Specification Document(s): {{sec-sw-components}} of {{&SELF}}

### Verification Service Indicator Claim

* Claim Name: arm-platform-verification-service-indicator
* Claim Description: Arm Platform Verification Service Indicator
* JWT Claim Name: N/A
* Claim Key: 2400
* Claim Value Type(s): text string
* Change Controller: Hannes Tschofenig
* Specification Document(s): {{sec-verification-service-indicator}} of {{&SELF}}

### Platform Config Claim

* Claim Name: arm-platform-config
* Claim Description: Arm Platform Configuration
* JWT Claim Name: N/A
* Claim Key: 2401
* Claim Value Type(s): byte string
* Change Controller: Hannes Tschofenig
* Specification Document(s): {{sec-platform-config}} of {{&SELF}}

### Platform Hash Algorithm ID Clain

* Claim Name: arm-platform-hash-algm-id
* Claim Description: Arm Platform Hash Algorithm ID
* JWT Claim Name: N/A
* Claim Key: 2402
* Claim Value Type(s): text string
* Change Controller: Hannes Tschofenig
* Specification Document(s): {{sec-arm-platform-hash-algm-id}} of {{&SELF}}

### CCA Token Platform Token Label

* Claim Name: cca-platform-token-label
* Claim Description: CCA Token Platform Token Label
* JWT Claim Name: N/A
* Claim Key: 44234
* Claim Value Type(s): byte string
* Change Controller: Hannes Tschofenig
* Specification Document(s): {{sec-cca-token-collection}} of {{&SELF}}

### Realm Personalization Value Claim

* Claim Name: cca-realm-personalization-value
* Claim Description: CCA Realm Personalisation Value
* JWT Claim Name: N/A
* Claim Key: 44235
* Claim Value Type(s): byte string
* Change Controller: Hannes Tschofenig
* Specification Document(s): {{sec-realm-personalisation-value-claim}} of {{&SELF}}

### Realm Hash Algorithm ID Claim

* Claim Name: cca-realm-hash-algm-id
* Claim Description: CCA Realm Hash Algorithm ID
* JWT Claim Name: N/A
* Claim Key: 44236
* Claim Value Type(s): text string
* Change Controller: Hannes Tschofenig
* Specification Document(s): {{sec-realm-hash-algm-id-claim}} of {{&SELF}}

### Realm Public Key Claim

* Claim Name: cca-realm-public-key
* Claim Description: CCA Realm Public Key
* JWT Claim Name: N/A
* Claim Key: 44237
* Claim Value Type(s): byte string
* Change Controller: Hannes Tschofenig
* Specification Document(s): {{sec-realm-public-key-claim}} of {{&SELF}}

### Realm Initial Measurement Claim

* Claim Name: cca-realm-initial-measurement
* Claim Description: CCA Realm Initial Measurement
* JWT Claim Name: N/A
* Claim Key: 44238
* Claim Value Type(s): byte string
* Change Controller: Hannes Tschofenig
* Specification Document(s): {{sec-realm-initial-measurement-claim}} of {{&SELF}}

### Realm Extensible Measurements Claim

* Claim Name: cca-realm-extensible-measurements
* Claim Description: CCA Realm Extensible Measurements
* JWT Claim Name: N/A
* Claim Key: 44239
* Claim Value Type(s): array
* Change Controller: Hannes Tschofenig
* Specification Document(s): {{sec-realm-initial-measurement-claim}} of {{&SELF}}

### Realm Public Key Hash Algorithm ID Claim

* Claim Name: cca-realm-public-key-hash-algm-id
* Claim Description: Realm Public Key Hash Algorithm ID Claim
* JWT Claim Name: N/A
* Claim Key: 44240
* Claim Value Type(s): text string
* Change Controller: Hannes Tschofenig
* Specification Document(s): {{sec-realm-public-key-hash-algo-id-claim}} of {{&SELF}}

### CCA Token Delegated Realm Token Label

* Claim Name: cca-platform-delegated-realm-label
* Claim Description: CCA Token Platform Token Label
* JWT Claim Name: N/A
* Claim Key: 44241
* Claim Value Type(s): byte string
* Change Controller: Hannes Tschofenig
* Specification Document(s): {{sec-cca-token-collection}} of {{&SELF}}



## Media Types
{: #sec-iana-media-types}

No new media type registration is requested.
To indicate that the transmitted content is a CCA attestation token,
applications can use the `application/eat+cwt` media type defined in
{{EAT-MEDIATYPES}} with the `eat_profile` parameter set to
`tag:arm.com,2023:cca_platform#1.0.0`.

## CoAP Content-Formats Registration
{: #sec-iana-coap-content-format}

IANA is requested to register a CoAP Content-Format ID in the "CoAP
Content-Formats" registry {{IANA-CoAP-Content-Formats}}:

* A registration for the `application/eat+cwt` media type with the `eat_profile` parameter
  equal to "tag:arm.com,2023:cca_platform#1.0.0"

The Content-Formats should be allocated from the Expert review range (0-255).

### Registry Contents

*  Media Type: `application/eat+cwt; eat_profile="tag:arm.com,2023:cca_platform#1.0.0"
*  Encoding: -
*  Id: To-be-assigned by IANA
*  Reference: {{&SELF}}

*  Media Type: `application/eat+cwt; eat_profile="tag:arm.com,2023:realm#1.0.0"
*  Encoding: -
*  Id: To-be-assigned by IANA
*  Reference: {{&SELF}}

--- back

# Examples

The following examples show CCA attestation tokens for an hypothetical system
comprising a single number of software component.
The attesting device is in a lifecycle state ({{sec-security-lifecycle}}) of
SECURED.

## Delegated Mode

The following sample claim set and token are representative of a CCA Token using "delegated mode" described in {{delegated}}.

In this model, the `eat_nonce` claim in the Platform token contains a hash of the RAK public key claim in the Realm token.

### Platform Claims Set

The CCA Platform claims set is

~~~ cbor-diag
{::include-fold cddl/platform/examples/3.diag}
~~~

### Realm Claims Set

The CCA Realm claims set is

~~~ cbor-diag
{::include-fold cddl/realm/examples/1.diag}
~~~

### Platform Attestation Key

The COSE Key representation of the Platform Attestation Key (PAK) used for creating the COSE Sign1 signature over the CCA Platform token is

~~~ cbor-diag
{::include-fold cddl/misc/pak.diag}
~~~

### Realm Attestation Key

The COSE Key representation of the Realm Attestation Key (RAK) used for creating the COSE Sign1 signature over the CCA Realm token is

~~~ cbor-diag
{::include-fold cddl/misc/rak.diag}
~~~

### Signed and Bound Assembly

The resulting CMW collection is

~~~
{::include-fold cddl/top/examples/1.diag}
~~~

which has the following base16 encoding:

~~~
{::include-fold cddl/top/examples/1.hex}
~~~

## Direct Mode

The following sample claim sets and the resulting CCA Token are representative of a CCA Token using "direct mode" ({{direct}}).

In "direct mode" the `eat_nonce` claim in the Platform token contains a hash of the Realm claims set, which includes verifier-provided challenge data.

TODO

# Acknowledgments
{:numbered="false"}

TODO

[^rfc-ed-note]: RFC Editor:
